from __future__ import absolute_import, division, print_function

import sys
sys.path.append('..')

from perfect_hash import Graph



class NewGraph(Graph):

    def check(self):
        """
        See if vertex values add up to edge values (mod N).
        """
        for vertex in range(self.N):
            for neighbor, edge_value in self.adjacent[vertex]:
                assert (self.vertex_values[vertex] +
                        self.vertex_values[neighbor]) % self.N == edge_value

    def calc_tree_sizes(self):
        """
        After running this method, the attribute size will contain a list,
        which maps the vertices to the size of the tree that vertex belongs
        to.
        """
        visited = self.N * [-1]  # -1 unvisited, otherwise the number of tree
        treenum = 0

        # Loop over all vertices, taking unvisited ones as roots.
        for root in range(self.N):
            if visited[root] >= 0:
                continue

            # explore tree starting at 'root'
            # Stack of vertices to visit, a list of tuples (parent, vertex)
            tovisit = [(None, root)]
            while tovisit:
                parent, vertex = tovisit.pop()
                visited[vertex] = treenum

                # Loop over adjacent vertices, but skip the vertex we arrived
                # here from the first time it is encountered.
                skip = True
                for neighbor, edge_value in self.adjacent[vertex]:
                    if skip and neighbor == parent:
                        skip = False
                        continue

                    if visited[neighbor] >= 0:
                        # We visited here before, so the graph is cyclic.
                        exit('Hmm, graph is cyclic.')

                    tovisit.append((vertex, neighbor))

            treenum += 1

        # maps the tree number to number of vertices within that tree
        treesizes = treenum * [0]
        for tree in visited:
            treesizes[tree] += 1

        self.size = [treesizes[visited[v]] for v in range(self.N)]

        if verbose:
            freq = (self.N + 1) * [0]
            for size in treesizes:
                freq[size] += 1

            sys.stderr.write(' Size   Trees\n')
            for i, f in enumerate(freq):
                if f:
                    sys.stderr.write('%5i %5i\n' % (i, f))
                if i == minsize-1:
                    sys.stderr.write('--------------\n')

    def write(self, fo, labels=False):
        self.calc_tree_sizes()

        fo.write('graph G {\n'
                 '  size = "8,8";\n'
                 '  edge [color="#ff0000"]\n')
        if labels:
            fo.write('  node [color="#a0e0ee", style=filled];\n')

            for vertex, value in enumerate(self.vertex_values):
                if self.size[vertex] < minsize:
                    continue
                fo.write('  { node [label="%i: %i"] v%i }\n' % (
                    vertex, value, vertex))
        else:
            fo.write('  node [color="#3377a0", label="",\n'
                     '        style=filled, shape=circle]\n')

        for vertex in range(self.N):          # edges
            if self.size[vertex] < minsize:
                continue
            for neighbor, edge_value in self.adjacent[vertex]:
                if neighbor > vertex:  continue
                fo.write('  v%i -- v%i%s;\n' %
                         (vertex, neighbor,
                          (' [label="%s: %i"]' % (K[edge_value], edge_value))
                          if labels else ''))
        fo.write('}\n')
        fo.close()


if __name__ == '__main__':
    import sys
    from optparse import OptionParser

    usage = "usage: %prog [options] [PYCODE]"

    description = """\
Given the python code for a perfect hash function which was generated by
perfect_hash.py, e.g. by '$ ../perfect_hash.py animals.txt >animals.py',
this program will create the graph which was used in determining the
perfect hash function.  The input python code may also be given to stdin.
The output is saved as in the .dot format which is used by the Graphviz
tools (see http://www.graphviz.org/) to generate a picture of the graph.
"""

    parser = OptionParser(usage = usage,
                          description = description,
                          prog = sys.argv[0])

    parser.add_option("-l", "--labels",
                      action  = "store_true",
                      help    = "Be verbose")

    parser.add_option("-m", "--minsize",
                      action  = "store",
                      default = 1,
                      type    = "int",
                      help    = "Include only trees in the output which "
                                "have at least INT vertices. "
                                "Default is %default, i.e. all trees are "
                                "included within the output.",
                      metavar = "INT")

    parser.add_option("-o", "--output",
                      action  = "store",
                      help    = "Specify output FILE explicitly. "
                                "Default, is stdout. ",
                      metavar = "FILE")

    parser.add_option("-v", "--verbose",
                      action  = "store_true",
                      help    = "Be verbose")

    options, args = parser.parse_args()

    if options.minsize > 0:
        minsize = options.minsize
    else:
        parser.error("minimal size of trees has to be larger than zero")

    verbose = options.verbose

    if len(args) > 1:
        parser.error("incorrect number of arguments")

    # --------------------- end parsing and checking -----------------------

    if verbose:
        sys.stderr.write('minsize (of trees): %i\n' % minsize)
        sys.stderr.write('labels (in output): %s\n' % options.labels)

    if len(args)==1:
        try:
            fi = open(args[0])
        except IOError:
            sys.exit("Error: Can't open `%s' for reading." % args[0])
    else:
        fi = sys.stdin

    exec(fi.read())

    g = NewGraph(len(G))
    g.vertex_values = G
    for key, hashval in zip(K, H):
        g.connect(hash_f(key, S1), hash_f(key, S2), hashval)
    g.check()

    if options.output:
        try:
            fo = open(options.output, 'w')
        except IOError :
            sys.exit("Error: Can't open `%s' for writing." % options.output)
    else:
        fo = sys.stdout

    g.write(fo, options.labels)
